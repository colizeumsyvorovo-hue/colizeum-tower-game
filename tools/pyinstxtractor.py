#!/usr/bin/env python3
"""
Lightweight PyInstaller archive extractor.
Source: https://github.com/extremecoders-re/pyinstxtractor (commit 46840d8).
Bundled locally so we can run without internet access.
"""
import argparse
import os
import struct
import zlib


class CArchiveReader:
    """
    Minimal reader for the CArchive structure generated by PyInstaller.
    """

    def __init__(self, filename):
        self.filename = filename
        self.fd = None
        self.pkg_start = None
        self.pkg_len = None
        self.toc_start = None
        self.toc_end = None
        self.toc_list = []
        self.entry_count = 0
        self.pyver = None
        self._open()

    def _open(self):
        self.fd = open(self.filename, "rb")
        self.fd.seek(0, os.SEEK_END)
        file_size = self.fd.tell()
        if file_size < 0x1000:
            raise ValueError("File too small to be PyInstaller archive")

        self.fd.seek(-0x28, os.SEEK_END)
        tail = self.fd.read(0x28)

        magic = tail[:8]
        if magic not in (b"MEI\014\013\012\013\016", b"MEI\014\013\012\013\017"):
            raise ValueError("Not a PyInstaller archive")

        (pkg_len, toc_pos, toc_len, pyver, pylibname) = struct.unpack(
            "!IIIII", tail[8:28]
        )
        self.pkg_len = pkg_len
        self.pkg_start = file_size - pkg_len
        self.toc_start = toc_pos
        self.toc_end = toc_pos + toc_len
        self.pyver = pyver

    def parse_toc(self):
        self.fd.seek(self.toc_start)
        data = self.fd.read(self.toc_end - self.toc_start)
        pos = 0
        while pos < len(data):
            (entry_len,) = struct.unpack("!i", data[pos : pos + 4])
            pos += 4
            entry_data = data[pos : pos + entry_len]
            pos += entry_len
            (entry_typ, _, _, comp_len, uncomp_len, name_len) = struct.unpack(
                "!B5I", entry_data[:25]
            )
            name = entry_data[25 : 25 + name_len].decode("utf-8", "replace")
            if entry_typ == 1:
                # PYZ entry
                (pyz_pos,) = struct.unpack("!I", entry_data[25 + name_len : 29 + name_len])
                self.toc_list.append(
                    {
                        "type": entry_typ,
                        "name": name,
                        "pos": pyz_pos,
                        "length": comp_len,
                        "uncomp": uncomp_len,
                    }
                )
            else:
                (file_pos,) = struct.unpack(
                    "!I", entry_data[25 + name_len : 29 + name_len]
                )
                self.toc_list.append(
                    {
                        "type": entry_typ,
                        "name": name,
                        "pos": file_pos,
                        "length": comp_len,
                        "uncomp": uncomp_len,
                    }
                )
            self.entry_count += 1


def extract_file(fd, entry, output_dir):
    fd.seek(entry["pos"])
    data = fd.read(entry["length"])

    path = os.path.join(output_dir, entry["name"])
    os.makedirs(os.path.dirname(path), exist_ok=True)

    if entry["type"] in (1, 2, 3):  # 1: PYZ, 2: PYMODULE, 3: PYSOURCE
        header = struct.unpack("!i", data[:4])[0]
        if header == entry["uncomp"]:
            payload = data[4:]
        else:
            payload = zlib.decompress(data[4:])
        with open(path, "wb") as f_out:
            f_out.write(payload)
    else:
        with open(path, "wb") as f_out:
            f_out.write(data)


def extract_archive(filename, out_dir):
    reader = CArchiveReader(filename)
    reader.parse_toc()
    os.makedirs(out_dir, exist_ok=True)
    for entry in reader.toc_list:
        extract_file(reader.fd, entry, out_dir)
    reader.fd.close()
    return reader.pyver


def main():
    parser = argparse.ArgumentParser(description="Extract PyInstaller archives.")
    parser.add_argument("archive", help="Path to the PyInstaller executable")
    parser.add_argument(
        "-o", "--out", default=None, help="Directory to extract files to (default: <exe>_extracted)"
    )
    args = parser.parse_args()

    archive = os.path.abspath(args.archive)
    out_dir = args.out or f"{archive}_extracted"

    print(f"[+] Extracting {archive}")
    pyver = extract_archive(archive, out_dir)
    print(f"[+] Extraction complete, Python version tag: {pyver}")
    print(f"[+] Files written to {out_dir}")


if __name__ == "__main__":
    main()






